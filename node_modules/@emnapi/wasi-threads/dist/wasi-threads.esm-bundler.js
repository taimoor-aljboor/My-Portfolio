var _WebAssembly = typeof WebAssembly !== 'undefined'
    ? WebAssembly
    : typeof WXWebAssembly !== 'undefined'
        ? WXWebAssembly
        : undefined;
var ENVIRONMENT_IS_NODE = typeof process === 'object' && process !== null &&
    typeof process.versions === 'object' && process.versions !== null &&
    typeof process.versions.node === 'string';
function getPostMessage(options) {
    return typeof (options === null || options === void 0 ? void 0 : options.postMessage) === 'function'
        ? options.postMessage
        : typeof postMessage === 'function'
            ? postMessage
            : undefined;
}
function serizeErrorToBuffer(sab, code, error) {
    var i32array = new Int32Array(sab);
    Atomics.store(i32array, 0, code);
    if (code > 1 && error) {
        var name_1 = error.name;
        var message = error.message;
        var stack = error.stack;
        var nameBuffer = new TextEncoder().encode(name_1);
        var messageBuffer = new TextEncoder().encode(message);
        var stackBuffer = new TextEncoder().encode(stack);
        Atomics.store(i32array, 1, nameBuffer.length);
        Atomics.store(i32array, 2, messageBuffer.length);
        Atomics.store(i32array, 3, stackBuffer.length);
        var buffer = new Uint8Array(sab);
        buffer.set(nameBuffer, 16);
        buffer.set(messageBuffer, 16 + nameBuffer.length);
        buffer.set(stackBuffer, 16 + nameBuffer.length + messageBuffer.length);
    }
}
function deserizeErrorFromBuffer(sab) {
    var _a, _b;
    var i32array = new Int32Array(sab);
    var status = Atomics.load(i32array, 0);
    if (status <= 1) {
        return null;
    }
    var nameLength = Atomics.load(i32array, 1);
    var messageLength = Atomics.load(i32array, 2);
    var stackLength = Atomics.load(i32array, 3);
    var buffer = new Uint8Array(sab);
    var nameBuffer = buffer.slice(16, 16 + nameLength);
    var messageBuffer = buffer.slice(16 + nameLength, 16 + nameLength + messageLength);
    var stackBuffer = buffer.slice(16 + nameLength + messageLength, 16 + nameLength + messageLength + stackLength);
    var name = new TextDecoder().decode(nameBuffer);
    var message = new TextDecoder().decode(messageBuffer);
    var stack = new TextDecoder().decode(stackBuffer);
    var ErrorConstructor = (_a = globalThis[name]) !== null && _a !== void 0 ? _a : (name === 'RuntimeError' ? ((_b = _WebAssembly.RuntimeError) !== null && _b !== void 0 ? _b : Error) : Error);
    var error = new ErrorConstructor(message);
    Object.defineProperty(error, 'stack', {
        value: stack,
        writable: true,
        enumerable: false,
        configurable: true
    });
    return error;
}
/** @public */
function isSharedArrayBuffer(value) {
    return ((typeof SharedArrayBuffer === 'function' && value instanceof SharedArrayBuffer) ||
        (Object.prototype.toString.call(value) === '[object SharedArrayBuffer]'));
}
/** @public */
function isTrapError(e) {
    try {
        return e instanceof _WebAssembly.RuntimeError;
    }
    catch (_) {
        return false;
    }
}

function createMessage(type, payload) {
    return {
        __emnapi__: {
            type: type,
            payload: payload
        }
    };
}

var WASI_THREADS_MAX_TID = 0x1FFFFFFF;
function checkSharedWasmMemory(wasmMemory) {
    if (wasmMemory) {
        if (!isSharedArrayBuffer(wasmMemory.buffer)) {
            throw new Error('Multithread features require shared wasm memory. ' +
                'Try to compile with `-matomics -mbulk-memory` and use `--import-memory --shared-memory` during linking, ' +
                'then create WebAssembly.Memory with `shared: true` option');
        }
    }
    else {
        if (typeof SharedArrayBuffer === 'undefined') {
            throw new Error('Current environment does not support SharedArrayBuffer, threads are not available!');
        }
    }
}
function getReuseWorker(value) {
    var _a;
    if (typeof value === 'boolean') {
        return value ? { size: 0, strict: false } : false;
    }
    if (typeof value === 'number') {
        if (!(value >= 0)) {
            throw new RangeError('reuseWorker: size must be a non-negative integer');
        }
        return { size: value, strict: false };
    }
    if (!value) {
        return false;
    }
    var size = (_a = Number(value.size)) !== null && _a !== void 0 ? _a : 0;
    var strict = Boolean(value.strict);
    if (!(size > 0) && strict) {
        throw new RangeError('reuseWorker: size must be set to positive integer if strict is set to true');
    }
    return { size: size, strict: strict };
}
var nextWorkerID = 0;
/** @public */
var ThreadManager = /*#__PURE__*/ (function () {
    function ThreadManager(options) {
        var _a;
        this.unusedWorkers = [];
        this.runningWorkers = [];
        this.pthreads = Object.create(null);
        this.wasmModule = null;
        this.wasmMemory = null;
        this.messageEvents = new WeakMap();
        if (!options) {
            throw new TypeError('ThreadManager(): options is not provided');
        }
        if ('childThread' in options) {
            this._childThread = Boolean(options.childThread);
        }
        else {
            this._childThread = false;
        }
        if (this._childThread) {
            this._onCreateWorker = undefined;
            this._reuseWorker = false;
            this._beforeLoad = undefined;
        }
        else {
            this._onCreateWorker = options.onCreateWorker;
            this._reuseWorker = getReuseWorker(options.reuseWorker);
            this._beforeLoad = options.beforeLoad;
        }
        this.printErr = (_a = options.printErr) !== null && _a !== void 0 ? _a : console.error.bind(console);
    }
    Object.defineProperty(ThreadManager.prototype, "nextWorkerID", {
        get: function () { return nextWorkerID; },
        enumerable: false,
        configurable: true
    });
    ThreadManager.prototype.init = function () {
        if (!this._childThread) {
            this.initMainThread();
        }
    };
    ThreadManager.prototype.initMainThread = function () {
        this.preparePool();
    };
    ThreadManager.prototype.preparePool = function () {
        if (this._reuseWorker) {
            if (this._reuseWorker.size) {
                var pthreadPoolSize = this._reuseWorker.size;
                while (pthreadPoolSize--) {
                    var worker = this.allocateUnusedWorker();
                    if (ENVIRONMENT_IS_NODE) {
                        // https://github.com/nodejs/node/issues/53036
                        worker.once('message', function () { });
                        worker.unref();
                    }
                }
            }
        }
    };
    ThreadManager.prototype.shouldPreloadWorkers = function () {
        return !this._childThread && this._reuseWorker && this._reuseWorker.size > 0;
    };
    ThreadManager.prototype.loadWasmModuleToAllWorkers = function () {
        var _this_1 = this;
        var promises = Array(this.unusedWorkers.length);
        var _loop_1 = function (i) {
            var worker = this_1.unusedWorkers[i];
            if (ENVIRONMENT_IS_NODE)
                worker.ref();
            promises[i] = this_1.loadWasmModuleToWorker(worker).then(function (w) {
                if (ENVIRONMENT_IS_NODE)
                    worker.unref();
                return w;
            }, function (e) {
                if (ENVIRONMENT_IS_NODE)
                    worker.unref();
                throw e;
            });
        };
        var this_1 = this;
        for (var i = 0; i < this.unusedWorkers.length; ++i) {
            _loop_1(i);
        }
        return Promise.all(promises).catch(function (err) {
            _this_1.terminateAllThreads();
            throw err;
        });
    };
    ThreadManager.prototype.preloadWorkers = function () {
        if (this.shouldPreloadWorkers()) {
            return this.loadWasmModuleToAllWorkers();
        }
        return Promise.resolve([]);
    };
    ThreadManager.prototype.setup = function (wasmModule, wasmMemory) {
        this.wasmModule = wasmModule;
        this.wasmMemory = wasmMemory;
    };
    ThreadManager.prototype.markId = function (worker) {
        if (worker.__emnapi_tid)
            return worker.__emnapi_tid;
        var tid = nextWorkerID + 43;
        nextWorkerID = (nextWorkerID + 1) % (WASI_THREADS_MAX_TID - 42);
        this.pthreads[tid] = worker;
        worker.__emnapi_tid = tid;
        return tid;
    };
    ThreadManager.prototype.returnWorkerToPool = function (worker) {
        var tid = worker.__emnapi_tid;
        if (tid !== undefined) {
            delete this.pthreads[tid];
        }
        this.unusedWorkers.push(worker);
        this.runningWorkers.splice(this.runningWorkers.indexOf(worker), 1);
        delete worker.__emnapi_tid;
        if (ENVIRONMENT_IS_NODE) {
            worker.unref();
        }
    };
    ThreadManager.prototype.loadWasmModuleToWorker = function (worker, sab) {
        var _this_1 = this;
        if (worker.whenLoaded)
            return worker.whenLoaded;
        var err = this.printErr;
        var beforeLoad = this._beforeLoad;
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        var _this = this;
        worker.whenLoaded = new Promise(function (resolve, reject) {
            var handleError = function (e) {
                var message = 'worker sent an error!';
                if (worker.__emnapi_tid !== undefined) {
                    message = 'worker (tid = ' + worker.__emnapi_tid + ') sent an error!';
                }
                if ('message' in e) {
                    err(message + ' ' + e.message);
                    if (e.message.indexOf('RuntimeError') !== -1 || e.message.indexOf('unreachable') !== -1) {
                        try {
                            _this.terminateAllThreads();
                        }
                        catch (_) { }
                    }
                }
                else {
                    err(message);
                }
                reject(e);
                throw e;
            };
            var handleMessage = function (data) {
                if (data.__emnapi__) {
                    var type = data.__emnapi__.type;
                    var payload = data.__emnapi__.payload;
                    if (type === 'loaded') {
                        worker.loaded = true;
                        if (ENVIRONMENT_IS_NODE && !worker.__emnapi_tid) {
                            worker.unref();
                        }
                        resolve(worker);
                        // if (payload.err) {
                        //   err('failed to load in child thread: ' + (payload.err.message || payload.err))
                        // }
                    }
                    else if (type === 'cleanup-thread') {
                        if (payload.tid in _this_1.pthreads) {
                            _this_1.cleanThread(worker, payload.tid);
                        }
                    }
                }
            };
            worker.onmessage = function (e) {
                handleMessage(e.data);
                _this_1.fireMessageEvent(worker, e);
            };
            worker.onerror = handleError;
            if (ENVIRONMENT_IS_NODE) {
                worker.on('message', function (data) {
                    var _a, _b;
                    (_b = (_a = worker).onmessage) === null || _b === void 0 ? void 0 : _b.call(_a, {
                        data: data
                    });
                });
                worker.on('error', function (e) {
                    var _a, _b;
                    (_b = (_a = worker).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, e);
                });
                worker.on('detachedExit', function () { });
            }
            if (typeof beforeLoad === 'function') {
                beforeLoad(worker);
            }
            try {
                worker.postMessage(createMessage('load', {
                    wasmModule: _this_1.wasmModule,
                    wasmMemory: _this_1.wasmMemory,
                    sab: sab
                }));
            }
            catch (err) {
                checkSharedWasmMemory(_this_1.wasmMemory);
                throw err;
            }
        });
        return worker.whenLoaded;
    };
    ThreadManager.prototype.allocateUnusedWorker = function () {
        var _onCreateWorker = this._onCreateWorker;
        if (typeof _onCreateWorker !== 'function') {
            throw new TypeError('`options.onCreateWorker` is not provided');
        }
        var worker = _onCreateWorker({ type: 'thread', name: 'emnapi-pthread' });
        this.unusedWorkers.push(worker);
        return worker;
    };
    ThreadManager.prototype.getNewWorker = function (sab) {
        if (this._reuseWorker) {
            if (this.unusedWorkers.length === 0) {
                if (this._reuseWorker.strict) {
                    if (!ENVIRONMENT_IS_NODE) {
                        var err = this.printErr;
                        err('Tried to spawn a new thread, but the thread pool is exhausted.\n' +
                            'This might result in a deadlock unless some threads eventually exit or the code explicitly breaks out to the event loop.');
                        return;
                    }
                }
                var worker_1 = this.allocateUnusedWorker();
                // eslint-disable-next-line @typescript-eslint/no-floating-promises
                this.loadWasmModuleToWorker(worker_1, sab);
            }
            return this.unusedWorkers.pop();
        }
        var worker = this.allocateUnusedWorker();
        // eslint-disable-next-line @typescript-eslint/no-fl